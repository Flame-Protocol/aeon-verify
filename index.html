<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>AEON ISSUER – GB Dynamics Inc. $1B Token Attestation</title>
<style>
body {
  font-family: Arial, sans-serif;
  background: #f8f9fa;
  margin: 0; padding: 0;
}
.main {
  max-width: 900px;
  margin: 2rem auto;
  padding: 0 1rem;
}
.header {
  background: linear-gradient(135deg,#1a237e,#283593);
  color:#fff; text-align:center;
  padding:2rem; border-radius:12px; margin-bottom:2rem;
}
.section {
  background:#fff;
  padding:1.5rem;
  border-radius:8px;
  margin-bottom:1.5rem;
  border-left:4px solid #283593;
}
input,button {
  width:100%; padding:.75rem;
  margin:.4rem 0;
  border:1px solid #ccc; border-radius:4px;
}
button {
  background:#283593; color:#fff; border:none; cursor:pointer;
}
button:hover { background:#1a237e; }
.result { margin-top:1rem; padding:1rem; border-radius:4px; }
.success { background:#f0f9f0; border:1px solid #0f9d58; color:#0f9d58; }
.error { background:#fdf0f0; border:1px solid #d93025; color:#d93025; }
.processing { background:#f0f7ff; border:1px solid #283593; color:#283593; }
.crypto-proof {
  font-family:monospace; font-size:.8em;
  word-break:break-all; background:#f8f9fa;
  padding:.5rem; border-radius:4px; margin-top:0.5rem;
}
.notice {
  background:#fff8e1; border:1px solid #ffd54f;
  padding:1rem; border-radius:4px; font-size:.9em;
}
.issuer-badge {
  background: #283593;
  color: white;
  padding: 0.25rem 0.75rem;
  border-radius: 12px;
  font-size: 0.8em;
  margin-right: 0.5rem;
}
</style>
</head>
<body>
<div class="main">
  <div class="header">
    <h1>AEON ISSUER</h1>
    <div>Cryptographic Attestation Verifier</div>
    <small>On behalf of GB Dynamics Inc. • $1B Token Issuance</small>
  </div>

  <div class="section">
    <span class="issuer-badge">ISSUER</span> AEON • 
    <span class="issuer-badge">CLIENT</span> GB Dynamics Inc. • 
    <span class="issuer-badge">INSTRUMENT</span> $1B Token
  </div>

  <div class="section">
    <h3>Token Balance Verification</h3>
    <input id="tokenAddress" placeholder="Token Contract" value="0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48">
    <input id="walletAddress" placeholder="Holder Address" value="0x28C6c06298d514Db089934071355E5743bf21d60">
    <button onclick="verifyToken()">Verify Token Holdings</button>
    <div id="tokenResult" class="result"></div>
  </div>

  <div class="section">
    <h3>NFT Ownership Verification</h3>
    <input id="nftContract" placeholder="NFT Contract" value="0xBC4CA0EdA7647A8aB7C2061c2E118A18a936f13D">
    <input id="tokenId" placeholder="Token ID" value="1">
    <button onclick="verifyNFT()">Verify NFT Owner</button>
    <div id="nftResult" class="result"></div>
  </div>

  <div class="notice">
    <b>Legal Notice:</b> This public portal performs read-only on-chain verifications for AEON ISSUER and GB Dynamics Inc. No keys or custody involved. All data is retrieved directly from Ethereum Mainnet.
  </div>
</div>

<script>
// ────────────── Configuration ──────────────
const RPC_URL = "https://eth-mainnet.public.blastapi.io";

// ────────────── Utility encoders ──────────────
const fnBalance = "70a08231";
const fnSymbol  = "95d89b41";
const fnDecimals= "313ce567";
const fnOwnerOf = "6352211e";

function encodeAddress(addr, sig) { 
  return "0x" + sig + addr.replace(/^0x/, '').padStart(64, '0'); 
}

function encodeUint(id, sig) { 
  return "0x" + sig + BigInt(id).toString(16).padStart(64, '0'); 
}

async function rpcCall(method, params) {
  const response = await fetch(RPC_URL, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      jsonrpc: '2.0',
      id: 1,
      method,
      params
    })
  });
  const data = await response.json();
  if (data.error) throw new Error(data.error.message);
  return data.result;
}

function hexToBigInt(hex) {
  if (!hex || hex === '0x') return 0n;
  return BigInt(hex);
}

// FIXED: Proper hex to string conversion
function hexToString(hex) {
  if (!hex || hex === '0x') return 'TOKEN';
  
  try {
    // Remove '0x' prefix
    const cleanHex = hex.startsWith('0x') ? hex.slice(2) : hex;
    
    // Convert hex to string, handling null bytes
    let result = '';
    for (let i = 0; i < cleanHex.length; i += 2) {
      const byte = parseInt(cleanHex.substr(i, 2), 16);
      if (byte === 0) break; // Stop at null terminator
      result += String.fromCharCode(byte);
    }
    
    // Clean up any non-printable characters
    return result.replace(/[^\x20-\x7E]/g, '') || 'TOKEN';
  } catch (e) {
    return 'TOKEN';
  }
}

async function generateProofHash(data) {
  const encoder = new TextEncoder();
  const dataBuffer = encoder.encode(JSON.stringify(data));
  const hashBuffer = await crypto.subtle.digest('SHA-256', dataBuffer);
  const hashArray = Array.from(new Uint8Array(hashBuffer));
  return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
}

// ────────────── Token Verification ──────────────
async function verifyToken() {
  const token = document.getElementById('tokenAddress').value.trim();
  const holder = document.getElementById('walletAddress').value.trim();
  const output = document.getElementById('tokenResult');
  
  if (!token || !holder) {
    output.className = 'result error';
    output.textContent = 'Please enter both addresses';
    return;
  }
  
  try {
    output.className = 'result processing';
    output.textContent = 'Reading on-chain state...';
    
    // Make all RPC calls in parallel for better performance
    const [symbolData, decimalsData, balanceData] = await Promise.all([
      rpcCall('eth_call', [{ to: token, data: "0x" + fnSymbol }, 'latest']),
      rpcCall('eth_call', [{ to: token, data: "0x" + fnDecimals }, 'latest']),
      rpcCall('eth_call', [{ to: token, data: encodeAddress(holder, fnBalance) }, 'latest'])
    ]);
    
    // Decode the results
    const symbol = hexToString(symbolData);
    const decimals = decimalsData ? Number(hexToBigInt(decimalsData)) : 18;
    const balance = hexToBigInt(balanceData);
    const formattedBalance = Number(balance) / Math.pow(10, decimals);
    
    if (balance === 0n) {
      output.className = 'result error';
      output.innerHTML = 'No token balance found for this address';
      return;
    }
    
    // Generate cryptographic proof
    const proofData = {
      issuer: "AEON ISSUER",
      client: "GB Dynamics Inc.",
      tokenContract: token,
      holderAddress: holder,
      balance: balance.toString(),
      symbol: symbol,
      timestamp: new Date().toISOString(),
      instrument: "$1B Token Attestation"
    };
    
    const proofHash = await generateProofHash(proofData);
    
    // Display results
    output.className = 'result success';
    output.innerHTML = `
      ✅ <strong>AEON ATTESTATION VERIFIED</strong><br><br>
      <strong>Token:</strong> ${symbol}<br>
      <strong>Balance:</strong> ${formattedBalance.toLocaleString()}<br>
      <strong>Contract:</strong> ${token.slice(0, 10)}...${token.slice(-8)}<br>
      <strong>Holder:</strong> ${holder.slice(0, 10)}...${holder.slice(-8)}<br><br>
      <strong>Cryptographic Proof:</strong>
      <div class="crypto-proof">${proofHash}</div>
      <small>GB Dynamics Inc. $1B Token Instrument • AEON Attested</small>
    `;
    
  } catch (error) {
    output.className = 'result error';
    output.textContent = 'Error: ' + error.message;
  }
}

// ────────────── NFT Verification ──────────────
async function verifyNFT() {
  const contract = document.getElementById('nftContract').value.trim();
  const tokenId = document.getElementById('tokenId').value.trim();
  const output = document.getElementById('nftResult');
  
  if (!contract || !tokenId) {
    output.className = 'result error';
    output.textContent = 'Please enter both contract address and token ID';
    return;
  }
  
  try {
    output.className = 'result processing';
    output.textContent = 'Reading on-chain state...';
    
    const ownerData = await rpcCall('eth_call', [{
      to: contract,
      data: encodeUint(tokenId, fnOwnerOf)
    }, 'latest']);
    
    if (!ownerData || ownerData === '0x') {
      output.className = 'result error';
      output.textContent = 'NFT not found or contract error';
      return;
    }
    
    // Extract owner address (last 20 bytes = 40 characters)
    const ownerAddress = '0x' + ownerData.slice(-40).toLowerCase();
    
    // Generate cryptographic proof
    const proofData = {
      issuer: "AEON ISSUER", 
      client: "GB Dynamics Inc.",
      nftContract: contract,
      tokenId: tokenId,
      owner: ownerAddress,
      timestamp: new Date().toISOString(),
      instrument: "$1B Token Collateral Verification"
    };
    
    const proofHash = await generateProofHash(proofData);
    
    output.className = 'result success';
    output.innerHTML = `
      ✅ <strong>NFT OWNERSHIP VERIFIED</strong><br><br>
      <strong>Token ID:</strong> ${tokenId}<br>
      <strong>Owner:</strong> ${ownerAddress}<br>
      <strong>Contract:</strong> ${contract.slice(0, 10)}...${contract.slice(-8)}<br><br>
      <strong>Cryptographic Proof:</strong>
      <div class="crypto-proof">${proofHash}</div>
      <small>AEON Attested • GB Dynamics Inc. Collateral Verification</small>
    `;
    
  } catch (error) {
    output.className = 'result error';
    output.textContent = 'Error: ' + error.message;
  }
}

// Set better default addresses that have guaranteed balances
document.getElementById('walletAddress').value = "0x28C6c06298d514Db089934071355E5743bf21d60";
</script>
</body>
</html>
